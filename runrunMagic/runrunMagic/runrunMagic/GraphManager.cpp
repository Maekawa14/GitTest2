#include "komon.h"

//-----------------------------------------------------------------------------
// @brief  コンストラクタ.f
//-----------------------------------------------------------------------------
GraphManager::GraphManager()
	: donutModelSourceHandle(-1)
	, jewelryModelSourceHandle(-1)
{

	count = 0;

	for (int i = 0; i < LINE_GRAPH_RAW; i++)
	{
		for (int j = 0; j < LINE_GRAPH_COL; j++)
		{
			graph[i][j] = NULL;
		}
	}
}

//-----------------------------------------------------------------------------
// @brief  デストラクタ.
//-----------------------------------------------------------------------------
GraphManager::~GraphManager()
{
	// 処理なし
}

//-----------------------------------------------------------------------------
// @brief  障害物生成.
//-----------------------------------------------------------------------------
void GraphManager::CreateGraph()
{
	//printfDx("Hit!\n");

	//宝石のモデル読み込み
	jewelryModelSourceHandle = MV1LoadModel("img/BackGround/houseki.x");
	// 障害物の配置図データとしてのlinemapを用意する.
	int map0[LINE_GRAPH_COL] = { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
								1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
								1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,
								1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
								1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,
								1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
								1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
								0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
								1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
								1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
								1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
								1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,
								1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
								1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,
								1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
								1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,
								1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
								1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
								1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
								1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
								1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
								1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
								1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
								1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
								1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
								1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
								1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
								1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	};
	int* lineMap[LINE_GRAPH_RAW] =
	{
		map0,
	};

	for (int i = 0; i < LINE_GRAPH_RAW; i++)
	{
		int* nowLine = lineMap[i];
		for (int j = 0; j < LINE_GRAPH_COL; j++)
		{
			// linemapに入っている数値によって障害物の種類を決定する.
			if (nowLine[j] == 1)
			{
				graph[i][j] = new GraphStatic(jewelryModelSourceHandle);
			}
			else
			{
				graph[i][j] = NULL;
			}


			// 位置の初期化.
			if (graph[i][j] != NULL)
			{
				graph[i][j]->SetPos(
					VGet(
					((GRAPH_SPACE_W * j) - (GRAPH_SPACE_W * LINE_GRAPH_COL)) + 3850,
						75,
					(GRAPH_SPACE_D * LINE_GRAPH_RAW) - (GRAPH_SPACE_D * i)));
            }
		}
	}

}

//-----------------------------------------------------------------------------
// @brief  障害物削除.
//-----------------------------------------------------------------------------
void GraphManager::DestroyGraph()
{

	for (int i = 0; i < LINE_GRAPH_RAW; i++)
	{
		for (int j = 0; j < LINE_GRAPH_COL; j++)
		{
			if (graph[i][j] != NULL)
			{
				delete(graph[i][j]);
				graph[i][j] = NULL;
			}
		}
	}
	MV1DeleteModel(jewelryModelSourceHandle);
	MV1DeleteModel(donutModelSourceHandle);
}

//-----------------------------------------------------------------------------
// @brief  更新.
//-----------------------------------------------------------------------------
void GraphManager::Update()
{
	for (int i = 0; i < LINE_GRAPH_RAW; i++)
	{
		for (int j = 0; j < LINE_GRAPH_COL; j++)
		{
			if (graph[i][j] != NULL)
			{
				graph[i][j]->Update();
			}
		}
	}
}

//-----------------------------------------------------------------------------
// @brief  描画.
//-----------------------------------------------------------------------------
void GraphManager::Draw(HitChecker& hitChecker)
{
	for (int i = 0; i < LINE_GRAPH_RAW; i++)
	{
		for (int j = 0; j < LINE_GRAPH_COL; j++)
		{
			if (graph[i][j] != NULL)
			{
				graph[i][j]->Draw();
			}
		}
	}
}

void GraphManager::Delete(int i, int j)
{
	delete(graph[i][j]);
	graph[i][j] = NULL;
}

//-----------------------------------------------------------------------------
// @brief  指定番号の障害物を取得.
//-----------------------------------------------------------------------------
GraphBase* GraphManager::GetGraph(int raw, int col)
{
	return graph[raw][col];
}